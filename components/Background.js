// This component is the background of the landing page. This also contains the animations of the 3D objects.
// You can interact with the 3D objects by hovering over them or clicking on them. Note the satellite doesn't do anything when clicked.
import { Canvas, useFrame } from "@react-three/fiber";
import { Sparkles } from "@react-three/drei";
import { useRef, Suspense } from "react";
// These imports are the 3D models generated by glbjsx once exported from blender.
import SatteliteModel from "./SatelliteModel";
import DonutModel from "./DonutModel";
import CarModel from "./CarModel";
import { PerspectiveCamera, Stars } from "@react-three/drei";

// The torus is the donut. The donut model is a mesh component.
// The donut moves in a bounding box on a plane behind the satellite.
// Mouse over it, and it stops in place and starts to pulsate, click on it, and it starts moving in a random direction again.
const Torus = () => {
  // This is a reference to the torus mesh, which can be used to update its position and rotation.
  const torusRef = useRef();
  // Some variables keep track of the speed of the torus, including its speed in the x direction, y direction and rotation speed.
  const torusSpeedX = useRef(0.04);
  const torusSpeedY = useRef(0.02);
  const torusRotationSpeed = useRef(0.01);
  // This variable allows the donut to start pulsating if it is true.
  const pulsate = useRef(false);
  const pulseDirection = useRef(1);

  // This function runs each rendered frame. By default it renders at 60fps.
  // So this function runs 60 times per second.
  useFrame(() => {
    // If the torus doesn't exist yet, we exit out.
    if (!torusRef.current) {
      return;
    }

    // The torus's x and y rotation are updated by the amount specified by the speed on each frame.
    torusRef.current.rotation.x += torusRotationSpeed.current;
    torusRef.current.rotation.y += torusRotationSpeed.current;
    //To avoid having very large numbers describing the rotation as we add to the rotation,
    // we reset the rotation value to zero after one full rotation.
    if (torusRef.current.rotation.x > 2 * Math.PI) {
      torusRef.current.rotation.x = 0;
    }
    if (torusRef.current.rotation.y > 2 * Math.PI) {
      torusRef.current.rotation.y = 0;
    }

    // The donut's position is updated by a value related to the speed.
    // The donut's x position is updated by its constant speed value, while its y
    // position is updated in a wavelike function using a sin function.
    torusRef.current.position.y +=
      torusSpeedY.current * Math.sin(0.5 * torusRef.current.position.x) * 2;
    torusRef.current.position.x += torusSpeedX.current;

    // If the donut's position exceeds the viewport, it is transported to the opposite side of
    // the viewport maintaining the same speed. In other words, this is the bounding box for the donut.
    // When the donut moves through the bounding box, it is returned to the other side of the screen.
    // These four if-statements describes one perameter of the binding box:

    // Topmost limit
    if (torusRef.current.position.y > 10) {
      torusRef.current.position.y = -10;
    }
    // Bottom limit
    if (torusRef.current.position.y < -10) {
      torusRef.current.position.y = 10;
    }
    // Right limit
    if (torusRef.current.position.x > 18) {
      torusRef.current.position.x = -18;
    }
    // Bottom limit
    if (torusRef.current.position.x < -18) {
      torusRef.current.position.x = 18;
    }

    // If pulsate becomes true, the torus's size starts changing based on the pulsating direction.
    // The pulsating direction is a number, either 1 or -1. If it is 1, the donut gets bigger,
    // and if it is -1, the donut gets smaller.
    // When the donut reaches 1.1 times its size, the pulsate direction changes to -1,
    // and when the donut reaches 0.9 times its size, the pulsate direction changes to +1 again.
    // This gives the pulsating effect.
    if (pulsate.current === true) {
      torusRef.current.scale.x += 0.008 * pulseDirection.current;
      torusRef.current.scale.y += 0.008 * pulseDirection.current;
      torusRef.current.scale.z += 0.008 * pulseDirection.current;

      if (torusRef.current.scale.x > 1.1) {
        pulseDirection.current = -1;
      }
      if (torusRef.current.scale.x < 0.9) {
        pulseDirection.current = 1;
      }
    }
  });
  return (
    // The mesh is animated, and inside the mesh, the 3D model of the donut is rendered. This code could have been in the Donut component,
    // but I decided to keep all the logic of objects moving in the same file.
    <mesh
      onPointerEnter={() => {
        // When you mouse over the torus, its speed reduces to zero and its rotation speed becomes constant.
        // It also begins to puslate.
        torusSpeedX.current = 0;
        torusSpeedY.current = 0;
        torusRotationSpeed.current = 0.01;
        pulsate.current = true;
      }}
      onClick={() => {
        // When you click on the torus, it starts rotating in a random direction, and its speed is set to a random value.
        torusRotationSpeed.current = Math.random() * 0.1;
        torusSpeedX.current = Math.random() * 0.18 - 0.09;
        torusSpeedY.current = Math.random() * 0.18 - 0.09;
        pulsate.current = false;
        // Its size is reset to normal as well.
        torusRef.current.scale.x = 1;
        torusRef.current.scale.y = 1;
        torusRef.current.scale.z = 1;
      }}
      ref={torusRef}
      position={[0, 0, -5]}
    >
      {/* The donut model from the Donut component, it is a mesh object, so we can change its scale. */}
      <DonutModel scale={[0.3, 0.3, 0.3]} />
    </mesh>
  );
};
// The satellite is a mesh component. It rotates in place, and if you leave your cursor over it,
// it will begin to start accelerating its rotation in the opposite direction.
const Satellite = () => {
  const satelliteRef = useRef();
  const satelliteRotationSpeed = useRef(0.01);
  const antiRotation = useRef(false);
  //Function run 60 times per second, or on each frame again.
  useFrame(() => {
    // If the satellite doesn't exist yet, return.
    if (!satelliteRef.current) {
      return;
    }

    // The satellite rotates along its y axis with the current rotation speed.
    satelliteRef.current.rotation.y += satelliteRotationSpeed.current;

    // To avoid the rotation number getting too big, we reset the rotation value after one full rotation.
    if (satelliteRef.current.rotation.x > 2 * Math.PI) {
      satelliteRef.current.rotation.x = 0;
    }
    if (satelliteRef.current.rotation.y > 2 * Math.PI) {
      satelliteRef.current.rotation.y = 0;
    }

    // If it is said that the satellite must rotate in the other direction, its
    // rotation speed will start changing constantly until it reaches a maximum anti-rotation speed.
    // Instead of affecting the rotation directly, we are affecting it through the speed, this means that instead of
    // changing its rotation instantly, it accelerates the rotation gradually over time.
    if (
      antiRotation.current === true &&
      satelliteRotationSpeed.current > -0.1
    ) {
      satelliteRotationSpeed.current -= 0.001;
    }
  });
  return (
    <mesh
      // Moving the satellite slightly back from the origin.
      position={[0, 0, -0.2]}
      ref={satelliteRef}
      // When the mouse enters the mesh, the antirotation variable is activated.
      // The only drawback here is that you have to keep the pointer still.
      onPointerEnter={() => {
        antiRotation.current = true;
      }}
      // When the pointer leaves the spaceship, the rotation speed is reset.
      onPointerLeave={() => {
        antiRotation.current = false;
        satelliteRotationSpeed.current = 0.01;
      }}
    >
      {/* The satellite model from the Satellite component. It is a mesh and can be scaled and rotated here.*/}
      <SatteliteModel scale={[0.4, 0.4, 0.4]} rotation={[0, 0, 0.3]} />
    </mesh>
  );
};
// This is the car that flies across the screen periodically. If you mouse over it, it will start to rotate,
// and it will speed up when you click on it. It does have a maximum speed, and if it is exceeded the speed is reset.
const Car = () => {
  // Again some variables to keep track of the car's state of motion.
  const carRotating = useRef(false);
  const carSpeedX = useRef(0.1);
  const borderLeft = -28;
  const borderRight = 28;
  const direction = useRef(1);
  const carRef = useRef();

  // Again this function is run each frame.
  useFrame(() => {
    // If there is no car element, we return.
    if (!carRef.current) {
      return;
    }
    // If the car is rotating, we let it rotate along the x axis.
    if (carRotating.current) {
      carRef.current.rotation.x += 0.1;
      // If the rotation is 360 degrees, it is reset to 0.
      if (carRef.current.rotation.x > Math.PI * 2) {
        carRef.current.rotation.x = 0;
      }
    }
    // The car's position is updated by the speed multiplied by the direction.
    // The direction is a value, either +1 or -1, determining the direction of travel of the car.
    carRef.current.position.x += carSpeedX.current * direction.current;

    // If the car reaches the left border of the screen, it turns around on its y axis, and its direction becomes positive.
    // We also choose a random height for the car between the bottom and top boundries.
    if (carRef.current.position.x < borderLeft) {
      carRef.current.rotation.y += Math.PI;
      direction.current = 1;
      carRef.current.position.y = Math.random() * 15 - 7;
    }
    // If the car reaches the right border, it is rotated along its y axis and its direction becomes negative.
    // We also choose a random height for the car between the bottom and top boundries.
    if (carRef.current.position.x > borderRight) {
      carRef.current.rotation.y += Math.PI;
      direction.current = -1;
      carRef.current.position.y = Math.random() * 15 - 7;
    }
  });
  return (
    <mesh
      ref={carRef}
      // Initial position of the car.
      position={[-20, 4, -10]}
      // If you mouse over the car, the rotation boolean becomes the opposite of what it is.
      onPointerEnter={() => {
        carRotating.current = !carRotating.current;
      }}
      // If you click on the car, its speed is increased, if its speed is increased beyond 0.4, it is reset to 0.1.
      onClick={() => {
        carSpeedX.current += 0.1;
        if (carSpeedX.current > 0.4) {
          carSpeedX.current = 0.1;
        }
      }}
    >
      {/* The car model from the Car component, scaled down and rotated to start its motion in the right direction. */}
      <CarModel scale={[0.25, 0.25, 0.25]} rotation-y={Math.PI / 2} />
    </mesh>
  );
};

const Background = () => {
  return (
    <Suspense
      fallback={
        <div className="loading">
          <h2>Waiting for interactive elements to load...</h2>
          <p>
            Let me introduce myself in the meantime. I am Gerhardus Cornelis
            Stefanus Cronjé.
          </p>
          <p>
            I started out as a teacher, then became a learning designer, and am
            now a web developer.
          </p>
        </div>
      }
    >
      {/* This canvas contains all the 3D objects. */}
      <Canvas>
        {/* Adding a perspective camera from three/drei and giving it a position. */}
        <PerspectiveCamera makeDefault position={[0, 0, 9]} />
        {/* Adding some lighting to the scene. */}
        <spotLight color="#fcf6da" intensity={1200} position={[-5, 5, 15]} />
        <spotLight color="#fcf6da" intensity={1200} position={[5, -10, 15]} />
        {/* Three/drei comes with a sparkles effect, they are sparse here, but still cute. */}
        <Sparkles scale={10} count={1000} />
        {/* Three/drei comes with a stars effect. */}
        <Stars />
        {/* The donut, satellite and car are also added to the scene. */}
        <Torus />
        <Satellite />
        <Car />
      </Canvas>
    </Suspense>
  );
};
export default Background;
